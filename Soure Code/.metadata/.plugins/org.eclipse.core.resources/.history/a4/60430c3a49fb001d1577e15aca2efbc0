/*
 * params.c
 *
 *  Created on: Mar 14, 2023
 *      Author: nguye
 */


#include "params.h"
#include "user_define.h"
#include <stm32f4xx.h>


params_t params={
#if PID_CONTROL_TYPE == 0
		.PID[0]={
				.KP=0,
				.KI=0,
				.KD=0,
				.minIpart = -2000,
				.maxIpart = 2000,
				.minDpart = -2000,
				.maxDpart = 2000,
				.minOut = -2000,
				.maxOut = 2000,

				.preIPart = 0,
				.preError = 0,
				.isFirstCompute = true
		},

		.PID[1]={
				.KP=0,
				.KI=0,
				.KD=0,
				.minIpart = -2000,
				.maxIpart = 2000,
				.minDpart = -2000,
				.maxDpart = 2000,
				.minOut = -2000,
				.maxOut = 2000,

				.preIPart = 0,
				.preError = 0,
				.isFirstCompute = true
		},

		.PID[2]={
				.KP=0,
				.KI=0,
				.KD=0,
				.minIpart = -2000,
				.maxIpart = 2000,
				.minDpart = -2000,
				.maxDpart = 2000,
				.minOut = -2000,
				.maxOut = 2000,

				.preIPart = 0,
				.preError = 0,
				.isFirstCompute = true
		},

		.PID[3]={
				.KP=0,
				.KI=0,
				.KD=0,
				.minIpart = -2000,
				.maxIpart = 2000,
				.minDpart = -2000,
				.maxDpart = 2000,
				.minOut = -2000,
				.maxOut = 2000,

				.preIPart = 0,
				.preError = 0,
				.isFirstCompute = true
		},
#elif PID_CONTROL_TYPE == 1
		.PID[0]={
				.KP=0,
				.KI=0,
				.KD=0,
				.min_alpha_part = -2000,
				.max_alpha_part = 2000,
				.min_beta_part = -2000,
				.max_beta_part = 2000,
				.min_gamma_part = -2000,
				.max_gamma_part = 2000,

				.preError  = 0,
				.pre2Error = 0,
				.isFirstCompute = true,
		},
		.PID[1]={
				.KP=0,
				.KI=0,
				.KD=0,
				.min_alpha_part = -2000,
				.max_alpha_part = 2000,
				.min_beta_part = -2000,
				.max_beta_part = 2000,
				.min_gamma_part = -2000,
				.max_gamma_part = 2000,

				.preError  = 0,
				.pre2Error = 0,
				.isFirstCompute = true,
		},
		.PID[2]={
				.KP=0,
				.KI=0,
				.KD=0,
				.min_alpha_part = -2000,
				.max_alpha_part = 2000,
				.min_beta_part = -2000,
				.max_beta_part = 2000,
				.min_gamma_part = -2000,
				.max_gamma_part = 2000,

				.preError  = 0,
				.pre2Error = 0,
				.isFirstCompute = true,
		},
		.PID[3]={
				.KP=0,
				.KI=0,
				.KD=0,
				.min_alpha_part = -2000,
				.max_alpha_part = 2000,
				.min_beta_part = -2000,
				.max_beta_part = 2000,
				.min_gamma_part = -2000,
				.max_gamma_part = 2000,

				.preError  = 0,
				.pre2Error = 0,
				.isFirstCompute = true,
		},
#endif
		.tilt_pitch_offset = 0,
		.tilt_roll_offset = 0,
		.tilt_yaw_offset = 0,

		.g_believe = 0.99,

		.ax_bias = 0,
		.ay_bias = 0,
		.az_bias = 0,

		.gx_bias = 0,
		.gy_bias = 0,
		.gz_bias = 0,

		.mx_bias = 0,
		.my_bias = 0,
		.mz_bias = 0,

		.mx_scale = 0,
		.my_scale = 0,
		.mz_scale = 0,
};

static uint32_t address = PARAMS_PAGE_ADDRESS;

static void write(uint32_t* ptr){
	HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, address, *ptr);
	address+=4;
}

static void read(uint32_t* ptr){
	*ptr = *((__IO uint32_t*)address);
	address+=4;
}

void params_save(){
	HAL_FLASH_Unlock();
		FLASH_EraseInitTypeDef EraseInitStruct;
		EraseInitStruct.TypeErase   = FLASH_TYPEERASE_SECTORS;
		EraseInitStruct.Sector = FLASH_SECTOR_11;
		EraseInitStruct.NbSectors     = 1;
		EraseInitStruct.VoltageRange = VOLTAGE_RANGE_3;

		uint32_t SectorError = 0;
		HAL_FLASHEx_Erase(&EraseInitStruct, &SectorError);

		address = PARAMS_PAGE_ADDRESS;

		uint32_t saved = HAVE_SAVED_DATA;
		write(&saved);

		//PID_Control_Data
		write((uint32_t*)(&params.PID[0].KP));
		write((uint32_t*)(&params.PID[0].KI));
		write((uint32_t*)(&params.PID[0].KD));

		write((uint32_t*)(&params.PID[1].KP));
		write((uint32_t*)(&params.PID[1].KI));
		write((uint32_t*)(&params.PID[1].KD));

		write((uint32_t*)(&params.PID[2].KP));
		write((uint32_t*)(&params.PID[2].KI));
		write((uint32_t*)(&params.PID[2].KD));

		write((uint32_t*)(&params.PID[3].KP));
		write((uint32_t*)(&params.PID[3].KI));
		write((uint32_t*)(&params.PID[3].KD));

		//IMU_Data
		write((uint32_t*)(&params.tilt_roll_offset));
		write((uint32_t*)(&params.tilt_pitch_offset));
		write((uint32_t*)(&params.tilt_yaw_offset));
		write((uint32_t*)(&params.g_believe));

		write((uint32_t*)(&params.gx_bias));
		write((uint32_t*)(&params.gy_bias));
		write((uint32_t*)(&params.gz_bias));

		write((uint32_t*)(&params.ax_bias));
		write((uint32_t*)(&params.ay_bias));
		write((uint32_t*)(&params.az_bias));

		write((uint32_t*)(&params.mx_bias));
		write((uint32_t*)(&params.my_bias));
		write((uint32_t*)(&params.mz_bias));

		write((uint32_t*)(&params.mx_scale));
		write((uint32_t*)(&params.my_scale));
		write((uint32_t*)(&params.mz_scale));

		HAL_FLASH_Lock();
}

bool params_load(){
	address = PARAMS_PAGE_ADDRESS;
	if((*(__IO uint32_t*) address) != HAVE_SAVED_DATA) return false;
		address+=4;

		read((uint32_t*)(&params.PID[0].KP));
		read((uint32_t*)(&params.PID[0].KI));
		read((uint32_t*)(&params.PID[0].KD));

		read((uint32_t*)(&params.PID[1].KP));
		read((uint32_t*)(&params.PID[1].KI));
		read((uint32_t*)(&params.PID[1].KD));

		read((uint32_t*)(&params.PID[2].KP));
		read((uint32_t*)(&params.PID[2].KI));
		read((uint32_t*)(&params.PID[2].KD));

		read((uint32_t*)(&params.PID[3].KP));
		read((uint32_t*)(&params.PID[3].KI));
		read((uint32_t*)(&params.PID[3].KD));

		read((uint32_t*)(&params.tilt_roll_offset));
		read((uint32_t*)(&params.tilt_pitch_offset));
		read((uint32_t*)(&params.tilt_yaw_offset));
		read((uint32_t*)(&params.g_believe));

		read((uint32_t*)(&params.gx_bias));
		read((uint32_t*)(&params.gy_bias));
		read((uint32_t*)(&params.gz_bias));

		read((uint32_t*)(&params.ax_bias));
		read((uint32_t*)(&params.ay_bias));
		read((uint32_t*)(&params.az_bias));

		read((uint32_t*)(&params.mx_bias));
		read((uint32_t*)(&params.my_bias));
		read((uint32_t*)(&params.mz_bias));

		read((uint32_t*)(&params.mx_scale));
		read((uint32_t*)(&params.my_scale));
		read((uint32_t*)(&params.mz_scale));

		return true;
}

